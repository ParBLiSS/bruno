/*
 * Copyright 2015 Georgia Institute of Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * debruijn_graph_loader.hpp
 *
 *  Created on: Aug 17, 2015
 *      Author: tony pan
 *      Author: yongchao
 */

#ifndef DEBRUIJN_GRAPH_LOADER_HPP_
#define DEBRUIJN_GRAPH_LOADER_HPP_

#include "bliss-config.hpp"

#include <utility>      // pair and utility functions.
#include <type_traits>

#include "utils/logging.h"

#include "common/alphabets.hpp"
#include "common/sequence.hpp"

#include "utils/kmer_utils.hpp"

#include "iterators/transform_iterator.hpp"
#include "iterators/zip_iterator.hpp"

#include "io/sequence_iterator.hpp"
#include "common/kmer_iterators.hpp"
#include "index/quality_score_iterator.hpp"
#include "debruijn/edge_iterator.hpp"

#include "utils/benchmark_utils.hpp"

namespace bliss
{
  namespace debruijn
  {
    //    	// generic class to create a directed de Bruijn graph
    // reuses the kmer index class
    // only need to supply correct de bruijn parser.

    /*generate de Bruijn graph nodes and edges from the reads*/
    /**
     * @tparam TupleType  value type of outputIt, or the generated type.  supplied so that we can use template template param with Index.
     */
    template <typename KmerType>
    struct debruijn_graph_parser {

        /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.  NOTE THAT THIS IS TYPE FOR THE OUTPUT.
        using edge_type = ::bliss::debruijn::compact_simple_biedge;
        using value_type = std::pair<KmerType, edge_type>;

        using Alphabet = typename KmerType::KmerAlphabet;

        template <typename SeqType, typename OutputIt>
        OutputIt operator()(SeqType & read, OutputIt output_iter) {
          static_assert(std::is_same<value_type, typename ::std::iterator_traits<OutputIt>::value_type>::value,
                        "output type and output container value type are not the same");

          // filter out EOL characters
          using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;
          // converter from ascii to alphabet values
          using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
          // kmer generation iterator
          using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;

          // handles the ascii to DNA16 mapping internally.
          using EdgeIterType = bliss::debruijn::iterator::biedge_generating_iterator<CharIter, ::bliss::common::DNA16>;


          // combine kmer iterator and position iterator to create an index iterator type.
          using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, EdgeIterType>;

          static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
                        value_type>::value,
                        "Generating iterator and output container value types differ");

          // then compute and store into index (this will generate kmers and insert into index)
          if (read.seq_begin == read.seq_end) return output_iter;

          //== set up the kmer generating iterators.
          bliss::index::kmer::NotEOL neol;
          KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
          KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


          // set up edge iterator.  returns the left and right chars around the kmer IN THE READ.
          EdgeIterType edge_start(CharIter(neol, read.seq_begin, read.seq_end), CharIter(neol, read.seq_end), KmerType::size);
          EdgeIterType edge_end (CharIter(neol, read.seq_end));


          // ==== set up the zip iterators
          KmerIndexIterType node_start (start, edge_start);
          KmerIndexIterType node_end(end, edge_end);

          return ::std::copy(node_start, node_end, output_iter);

        }
    };

    /*generate de Brujin graph nodes and edges, which each node associated with base quality scores*/
    template <typename KmerType, typename QualType=double,
        template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec>
    struct debruijn_graph_quality_parser {

        /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.  NOTE THAT THIS IS TYPE FOR THE OUTPUTIT.
        using edge_type = ::bliss::debruijn::compact_simple_biedge;
        using value_type = std::pair<KmerType, std::pair<edge_type, QualType> >;

        using Alphabet = typename KmerType::KmerAlphabet;

        template <typename SeqType, typename OutputIt>
        OutputIt operator()(SeqType & read, OutputIt output_iter) {

          static_assert(std::is_same<value_type, typename ::std::iterator_traits<OutputIt>::value_type>::value,
                        "output type and output container value type are not the same");


          // filter out EOL characters
          using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;
          // converter from ascii to alphabet values
          using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
          // kmer generation iterator
          using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;

          // handles the ascii to DNA16 mapping internally.
          using EdgeIterType = bliss::debruijn::iterator::biedge_generating_iterator<CharIter, bliss::common::DNA16>;

          // also remove eol from quality score
          using QualIterType =
              bliss::index::QualityScoreGenerationIterator<bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>, KmerType::size, QualityEncoder<QualType> >;

          // combine kmer iterator and position iterator to create an index iterator type.
          using KmerInfoIterType = bliss::iterator::ZipIterator<EdgeIterType, QualIterType>;

          using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, KmerInfoIterType>;

          static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
                        value_type>::value,
                        "generating iterator and output iterator's value types differ");


          // then compute and store into index (this will generate kmers and insert into index)
          if (read.seq_begin == read.seq_end || read.qual_begin == read.qual_end) return output_iter;

          //== set up the kmer generating iterators.
          bliss::index::kmer::NotEOL neol;
          KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
          KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


          // set up edge iterator.  returns the left and right chars around the kmer IN THE READ.
          EdgeIterType edge_start(CharIter(neol, read.seq_begin, read.seq_end), CharIter(neol, read.seq_end), KmerType::size);
          EdgeIterType edge_end (CharIter(neol, read.seq_end));


          QualIterType qual_start(CharIter(neol, read.qual_begin, read.qual_end));
          QualIterType qual_end(CharIter(neol, read.qual_end));

          KmerInfoIterType info_start(edge_start, qual_start);
          KmerInfoIterType info_end(edge_end, qual_end);



          // ==== set up the zip iterators
          KmerIndexIterType node_start(start, info_start);
          KmerIndexIterType node_end(end, info_end);

          return ::std::copy(node_start, node_end, output_iter);

        }
    };


  } /* namespace debruijn */
} /* namespace bliss */

#endif /* DEBRUIJN_GRAPH_LOADER_HPP_ */
