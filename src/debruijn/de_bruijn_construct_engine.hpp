/*
 * Copyright 2015 Georgia Institute of Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * de_bruijn_construct_engine.hpp
 *
 *  Created on: Aug 17, 2015
 *      Author: yongchao
 *      Author: tony pan
 */

#ifndef DE_BRUIJN_CONSTRUCT_ENGINE_HPP_
#define DE_BRUIJN_CONSTRUCT_ENGINE_HPP_

#include "bliss-config.hpp"

#if defined(USE_MPI)
#include "mpi.h"
#endif

//#if defined(USE_OPENMP)
//#include "omp.h"
//#endif

#include <utility>      // pair and utility functions.
#include <type_traits>

#include "utils/logging.h"
#include "common/alphabets.hpp"
#include "common/kmer.hpp"
#include "common/base_types.hpp"
#include "common/sequence.hpp"

#include "utils/kmer_utils.hpp"

#include "iterators/transform_iterator.hpp"
#include "iterators/zip_iterator.hpp"

#include "io/sequence_iterator.hpp"
#include "common/kmer_iterators.hpp"
#include "index/quality_score_iterator.hpp"
#include "debruijn/edge_iterator.hpp"

#include "index/kmer_index.hpp"

#include "utils/benchmark_utils.hpp"

namespace bliss
{
  namespace de_bruijn
  {
//    	// generic class to create a directed de Bruijn graph
      // reuses the kmer index class
      // only need to supply correct de bruijn parser.


  /*generate de Bruijn graph nodes and edges from the reads*/
    /**
     * @tparam TupleType  value type of outputIt, or the generated type.  supplied so that we can use template template param with Index.
     */
   template <typename KmerType, typename EdgeEncoding = bliss::common::DNA16>
	 struct de_bruijn_parser {

	   static_assert(std::is_same<EdgeEncoding, bliss::common::DNA16>::value, "Currently only support DNA16 as edge encoder");

      /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.  NOTE THAT THIS IS TYPE FOR THE OUTPUT.
      using edge_type = bliss::common::Kmer<2, EdgeEncoding, uint8_t>;
      using value_type = std::pair<KmerType, edge_type>;

      using Alphabet = typename KmerType::KmerAlphabet;

		 template <typename SeqType, typename OutputIt>
		 OutputIt operator()(SeqType & read, OutputIt output_iter) {
		   static_assert(std::is_same<value_type, typename ::std::iterator_traits<OutputIt>::value_type>::value,
		                  "output type and output container value type are not the same");

	      // filter out EOL characters
	       using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;
	       // converter from ascii to alphabet values
	       using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
	       // kmer generation iterator
	       using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;


       using EdgeIterType = bliss::iterator::edge_iterator<CharIter, EdgeEncoding>;


		   // combine kmer iterator and position iterator to create an index iterator type.
		   using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, EdgeIterType>;

		    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
		                  value_type>::value,
		        "Generating iterator and output container value types differ");

		    // then compute and store into index (this will generate kmers and insert into index)
		     if (read.seq_begin == read.seq_end) return output_iter;

		     //== set up the kmer generating iterators.
		     bliss::index::kmer::NotEOL neol;
		     KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
		     KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


		     // set up edge iterator.  returns the left and right chars around the kmer IN THE READ.
	       EdgeIterType edge_start(CharIter(neol, read.seq_begin, read.seq_end), CharIter(neol, read.seq_end), KmerType::size);
	       EdgeIterType edge_end (CharIter(neol, read.seq_end));


	       // ==== set up the zip iterators
	       KmerIndexIterType node_start (start, edge_start);
	       KmerIndexIterType node_end(end, edge_end);

	       return ::std::copy(node_start, node_end, output_iter);

		 }
	 };

	 /*generate de Brujin graph nodes and edges, which each node associated with base quality scores*/
    template <typename KmerType, typename QualType=double, typename EdgeEncoding = bliss::common::DNA16,
        template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec>
	 struct de_bruijn_quality_parser {

 	   static_assert(std::is_same<EdgeEncoding, bliss::common::DNA16>::value, "Currently only support DNA16 as edge encoder");

        /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.  NOTE THAT THIS IS TYPE FOR THE OUTPUTIT.
        using edge_type = ::bliss::common::Kmer<2, EdgeEncoding, uint8_t>;
        using value_type = std::pair<KmerType, std::pair<edge_type, QualType> >;

        using Alphabet = typename KmerType::KmerAlphabet;

       template <typename SeqType, typename OutputIt>
       OutputIt operator()(SeqType & read, OutputIt output_iter) {

         static_assert(std::is_same<value_type, typename ::std::iterator_traits<OutputIt>::value_type>::value,
                        "output type and output container value type are not the same");


         // filter out EOL characters
          using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;
          // converter from ascii to alphabet values
          using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
          // kmer generation iterator
          using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;


          using EdgeIterType = bliss::iterator::edge_iterator<CharIter, EdgeEncoding>;

          // also remove eol from quality score
          using QualIterType =
              bliss::index::QualityScoreGenerationIterator<bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>, KmerType::size, QualityEncoder<QualType> >;

          // combine kmer iterator and position iterator to create an index iterator type.
          using KmerInfoIterType = bliss::iterator::ZipIterator<EdgeIterType, QualIterType>;

          using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, KmerInfoIterType>;

          static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
                                     value_type>::value,
              "generating iterator and output iterator's value types differ");


           // then compute and store into index (this will generate kmers and insert into index)
           if (read.seq_begin == read.seq_end || read.qual_begin == read.qual_end) return output_iter;

           //== set up the kmer generating iterators.
           bliss::index::kmer::NotEOL neol;
           KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
           KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


           // set up edge iterator.  returns the left and right chars around the kmer IN THE READ.
           EdgeIterType edge_start(CharIter(neol, read.seq_begin, read.seq_end), CharIter(neol, read.seq_end), KmerType::size);
           EdgeIterType edge_end (CharIter(neol, read.seq_end));


           QualIterType qual_start(CharIter(neol, read.qual_begin, read.qual_end));
            QualIterType qual_end(CharIter(neol, read.qual_end));

            KmerInfoIterType info_start(edge_start, qual_start);
            KmerInfoIterType info_end(edge_end, qual_end);



           // ==== set up the zip iterators
            KmerIndexIterType node_start(start, info_start);
            KmerIndexIterType node_end(end, info_end);

           return ::std::copy(node_start, node_end, output_iter);

		 }
	 };


    // tODO: change MAP alphabet type to DNA
//	template <template <typename> class MapType>
//	using de_bruijn_engine = ::bliss::index::kmer::Index<MapType<bliss::common::DNA>, de_bruijn_parser<typename MapType<bliss::common::DNA>::key_type, bliss::common::DNA16 > >;
//
//	template <template <typename> class MapType, template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec >
//	using de_bruijn_quality_engine = ::bliss::index::kmer::Index<MapType<bliss::common::DNA>, de_bruijn_quality_parser<typename MapType<bliss::common::DNA>::key_type, typename std::tuple_element<1, typename MapType<bliss::common::DNA>::mapped_type>::type, bliss::common::DNA16, QualityEncoder > >;
//
//	template <template <typename> class MapType>
//	using de_bruijn_engine_ascii = ::bliss::index::kmer::Index<MapType<bliss::common::ASCII>, de_bruijn_parser<typename MapType<bliss::common::ASCII>::key_type, bliss::common::ASCII > >;
//
//	template <template <typename> class MapType, template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec >
//	using de_bruijn_quality_engine_ascii = ::bliss::index::kmer::Index<MapType<bliss::common::ASCII>, de_bruijn_quality_parser<typename MapType<bliss::common::ASCII>::key_type, typename std::tuple_element<1, typename MapType<bliss::common::ASCII>::mapped_type>::type, bliss::common::ASCII, QualityEncoder > >;


  } /* namespace de_bruijn */
} /* namespace bliss */

#endif /* DE_BRUIJN_CONSTRUCT_ENGINE_HPP_ */
