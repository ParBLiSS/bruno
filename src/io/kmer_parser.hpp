/*
 * Copyright 2015 Georgia Institute of Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file    kmer_parser.hpp
 * @ingroup io
 * @author  Tony Pan <tpan7@gatech.edu>
 * @brief kmer parsers definitions
 * @details 4 primary Kmer Parser classes are currently provided:
 *      Kmer
 *      Kmer Count tuple,
 *      Kmer Position tuple, and
 *      Kmer Position + Quality score tuple.
 *
 *
 */
#ifndef KMER_PARSER_HPP_
#define KMER_PARSER_HPP_

#include "bliss-config.hpp"

#if defined(USE_MPI)
#include "mpi.h"
#endif

//#if defined(USE_OPENMP)
//#include "omp.h"
//#endif

#include <tuple>        // tuple and utility functions
#include <utility>      // pair and utility functions.
#include <type_traits>
#include <cctype>       // tolower.

#include "utils/logging.h"
#include "utils/file_utils.hpp"
#include "common/alphabets.hpp"
#include "common/kmer.hpp"
#include "common/base_types.hpp"
#include "common/sequence.hpp"
#include "utils/kmer_utils.hpp"
#include "index/kmer_hash.hpp"
#include "common/kmer_transform.hpp"

#include "io/sequence_iterator.hpp"
#include "io/sequence_id_iterator.hpp"
#include "iterators/transform_iterator.hpp"
#include "common/kmer_iterators.hpp"
#include "iterators/zip_iterator.hpp"
#include "iterators/unzip_iterator.hpp"
#include "iterators/constant_iterator.hpp"
#include "index/quality_score_iterator.hpp"
#include "containers/fsc_container_utils.hpp"

namespace bliss
{
namespace index
{
namespace kmer
{


template <typename Iter>
using NonEOLIter = bliss::iterator::filter_iterator<::bliss::utils::file::NotEOL, Iter>;


/**
 * @tparam KmerType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename KmerType>
struct KmerParser {

    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = KmerType;
  using kmer_type = KmerType;


  /**
   * @brief generate kmers from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::fsc::TruePredicate>
  OutputIt operator()(SeqType & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<KmerType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
            "output type and output container value type are not the same");

    using Alphabet = typename KmerType::KmerAlphabet;

    /// converter from ascii to alphabet values
    using BaseCharIterator = bliss::iterator::transform_iterator<NonEOLIter<typename SeqType::IteratorType>, bliss::common::ASCII2<Alphabet> >;

    /// kmer generation iterator
    using KmerIterType = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;

    static_assert(std::is_same<typename std::iterator_traits<KmerIterType>::value_type,
        KmerType>::value,
        "input iterator and output iterator's value types differ");

    // then compute and store into index (this will generate kmers and insert into index)
    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;

    //== filtering iterator
    bliss::utils::file::NotEOL neol;
    NonEOLIter<typename SeqType::IteratorType> eolstart(neol, read.seq_begin, read.seq_end);
    NonEOLIter<typename SeqType::IteratorType> eolend(neol, read.seq_end);

    //== set up the kmer generating iterators.
    KmerIterType start(BaseCharIterator(eolstart, bliss::common::ASCII2<Alphabet>()), true);
    KmerIterType end(BaseCharIterator(eolend, bliss::common::ASCII2<Alphabet>()), false);

//    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());

    if (::std::is_same<Predicate, ::fsc::TruePredicate>::value)
      return ::std::copy(start, end, output_iter);
    else
      return ::std::copy_if(start, end, output_iter, pred);

  }
};


/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType>
struct KmerPositionTupleParser {

    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;


  /**
   * @brief generate kmer-position pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::fsc::TruePredicate>
  OutputIt operator()(SeqType & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
            "output type and output container value type are not the same");
    static_assert(::std::tuple_size<TupleType>::value == 2, "kmer-pos-qual index data type should be a pair");

    using KmerType = typename std::tuple_element<0, TupleType>::type;
    using Alphabet = typename KmerType::KmerAlphabet;

    // filter out EOL characters
    using CharIter = NonEOLIter<typename SeqType::IteratorType>;
    // converter from ascii to alphabet values
    using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
    // kmer generation iterator
    using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;

    //== next figure out starting positions for the kmers, accounting for EOL char presenses.
    using IdType = typename std::tuple_element<1, TupleType>::type;
    // kmer position iterator type
    using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;

    // use zip iterator to tie together the iteration of sequence raw data and id.
    using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;
    using CharPosIter = NonEOLIter<PairedIter>;
    // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
    // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
    using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter, 1>;

    // rezip the results
    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, IdIter>;

    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
        TupleType>::value,
        "input iterator and output iterator's value types differ");


    // then compute and store into index (this will generate kmers and insert into index)
    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;  // if too short...

    //== set up the kmer generating iterators.
    bliss::utils::file::NotEOL neol;
    KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
    KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


    //== set up the position iterators
    IdType seq_begin_id(read.id);
    seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
    IdType seq_end_id(seq_begin_id);
    seq_end_id += read.seq_size();

    // tie chars and id together
    PairedIter pp_begin(read.seq_begin, IdIterType(seq_begin_id));
    PairedIter pp_end(read.seq_end, IdIterType(seq_end_id));

    // filter eol
    CharPosIter cp_begin(neol, pp_begin, pp_end);
    CharPosIter cp_end(neol, pp_end);

    // ==== extract new id and rezip iterators
    KmerIndexIterType index_start(start, IdIter(cp_begin));
    KmerIndexIterType index_end(end, IdIter(cp_end));


//    for (; index_start != index_end; ++index_start) {
//      auto tp = *index_start;
//
//      printf("TCP id = %lu, pos = %lu, kmer = %s\n", tp.second.get_id(), tp.second.get_pos(), bliss::utils::KmerUtils::toASCIIString(tp.first).c_str());
//
//      *output_iter = tp;
//
//    }
    if (::std::is_same<Predicate, ::fsc::TruePredicate>::value)
      return ::std::copy(index_start, index_end, output_iter);
    else
      return ::std::copy_if(index_start, index_end, output_iter, pred);
  }

};


/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType, template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec>
struct KmerPositionQualityTupleParser {

    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;

  /**
   * @brief generate kmer-position-quality pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::fsc::TruePredicate>
  OutputIt operator()(SeqType & read, OutputIt output_iter, Predicate const & pred = Predicate()) {


    static_assert(SeqType::has_quality(), "Sequence Parser needs to support quality scores");

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
        "output type and output container value type are not the same");

    static_assert(::std::tuple_size<TupleType>::value == 2, "kmer-pos-qual index data type should be a pair");

    using KmerType = typename std::tuple_element<0, TupleType>::type;
    using Alphabet = typename KmerType::KmerAlphabet;

    static_assert(::std::tuple_size<typename std::tuple_element<1, TupleType>::type>::value == 2, "pos-qual index data type should be a pair");


    // filter out EOL characters
    using CharIter = NonEOLIter<typename SeqType::IteratorType>;
    // converter from ascii to alphabet values
    using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
    // kmer generation iterator
    using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;

    //== next figure out starting positions for the kmers, accounting for EOL char presenses.
    using IdType = typename std::tuple_element<0, typename std::tuple_element<1, TupleType>::type >::type;
    // kmer position iterator type
    using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;

    // use zip iterator to tie together the iteration of sequence raw data and id.
    using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;
    using CharPosIter = NonEOLIter<PairedIter>;
    // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
    // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
    using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter, 1>;


    using QualType = typename std::tuple_element<1, typename std::tuple_element<1, TupleType>::type>::type;
    //static_assert(::std::is_same<typename SeqType::IdType, IdType>::value, "position type does not match for input and output iterators" );

    // also remove eol from quality score
    using QualIterType =
        bliss::index::QualityScoreGenerationIterator<NonEOLIter<typename SeqType::IteratorType>, KmerType::size, QualityEncoder<QualType> >;

    /// combine kmer iterator and position iterator to create an index iterator type.
    using KmerInfoIterType = bliss::iterator::ZipIterator<IdIter, QualIterType>;

    static_assert(std::is_same<typename std::iterator_traits<KmerInfoIterType>::value_type,
        typename std::tuple_element<1, TupleType>::type >::value,
        "kmer info input iterator and output iterator's value types differ");


    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, KmerInfoIterType>;

    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
        TupleType>::value,
        "input iterator and output iterator's value types differ");


    // then compute and store into index (this will generate kmers and insert into index)
    if ((::std::distance(read.seq_begin, read.seq_end) < KmerType::size) ||
        (::std::distance(read.qual_begin, read.qual_end) < KmerType::size)) return output_iter;
    assert(::std::distance(read.seq_begin, read.seq_end) <= ::std::distance(read.qual_begin, read.qual_end));


    //== set up the kmer generating iterators.
    bliss::utils::file::NotEOL neol;
    KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
    KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);


    //== set up the position iterators
    IdType seq_begin_id(read.id);
    seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
    IdType seq_end_id(seq_begin_id);
    seq_end_id += read.seq_size();

    // tie chars and id together
    PairedIter pp_begin(read.seq_begin, IdIterType(seq_begin_id));
    PairedIter pp_end(read.seq_end, IdIterType(seq_end_id));

    // filter eol
    CharPosIter cp_begin(neol, pp_begin, pp_end);
    CharPosIter cp_end(neol, pp_end);

    // ==== quality scoring
    // filter eol and generate quality scores
    QualIterType qual_start(CharIter(neol, read.qual_begin, read.qual_end));
    QualIterType qual_end(CharIter(neol, read.qual_end));

    KmerInfoIterType info_start(IdIter(cp_begin), qual_start);
    KmerInfoIterType info_end(IdIter(cp_end), qual_end);


    // ==== set up the zip iterators
    KmerIndexIterType index_start(start, info_start);
    KmerIndexIterType index_end(end, info_end);

    //    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());

    if (::std::is_same<Predicate, ::fsc::TruePredicate>::value)
      return ::std::copy(index_start, index_end, output_iter);
    else
      return ::std::copy_if(index_start, index_end, output_iter, pred);
  }
};



/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType>
struct KmerCountTupleParser {

  /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;

  /**
   * @brief generate kmer-count pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::fsc::TruePredicate>
  OutputIt operator()(SeqType & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
        "output type and output container value type are not the same");
    static_assert(::std::tuple_size<TupleType>::value == 2, "count data type should be a pair");

    using KmerType = typename std::tuple_element<0, TupleType>::type;
    using CountType = typename std::tuple_element<1, TupleType>::type;

    using Alphabet = typename KmerType::KmerAlphabet;

    /// converter from ascii to alphabet values
    using BaseCharIterator = bliss::iterator::transform_iterator<NonEOLIter<typename SeqType::IteratorType>, bliss::common::ASCII2<Alphabet> >;

    /// kmer generation iterator
    using KmerIterType = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;
    using CountIterType = bliss::iterator::ConstantIterator<CountType>;

    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIterType, CountIterType>;

    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type, std::pair<KmerType, CountType> >::value,
        "count zip iterator not producing the right type.");

    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
        TupleType>::value,
        "count: input iterator and output iterator's value types differ");

    CountIterType count_start(1);

    // then compute and store into index (this will generate kmers and insert into index)
    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;

    //== set up the kmer generating iterators.
    bliss::utils::file::NotEOL neol;
    NonEOLIter<typename SeqType::IteratorType> eolstart(neol, read.seq_begin, read.seq_end);
    NonEOLIter<typename SeqType::IteratorType> eolend(neol, read.seq_end);

    KmerIterType start(BaseCharIterator(eolstart, bliss::common::ASCII2<Alphabet>()), true);
    KmerIterType end(BaseCharIterator(eolend, bliss::common::ASCII2<Alphabet>()), false);

    KmerIndexIterType istart(start, count_start);
    KmerIndexIterType iend(end, count_start);

    //    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());

    if (::std::is_same<Predicate, ::fsc::TruePredicate>::value)
      return ::std::copy(istart, iend, output_iter);
    else
      return ::std::copy_if(istart, iend, output_iter, pred);
  }

};

} /* namespace kmer */

} /* namespace index */
} /* namespace bliss */

#endif /* KMER_PARSER_HPP_ */
