/*
 * Copyright 2015 Georgia Institute of Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file    kmer_parser.hpp
 * @ingroup io
 * @author  Tony Pan <tpan7@gatech.edu>
 * @brief kmer parsers definitions
 * @details 4 primary Kmer Parser classes are currently provided:
 *      Kmer
 *      Kmer Count tuple,
 *      Kmer Position tuple, and
 *      Kmer Position + Quality score tuple.
 *
 *
 */
#ifndef KMER_PARSER_HPP_
#define KMER_PARSER_HPP_

#include "bliss-config.hpp"

#if defined(USE_MPI)
#include "mpi.h"
#endif

//#if defined(USE_OPENMP)
//#include "omp.h"
//#endif

#include <tuple>        // tuple and utility functions
#include <utility>      // pair and utility functions.
#include <type_traits>
#include <cctype>       // tolower.

#include "utils/logging.h"
#include "utils/file_utils.hpp"
#include "common/alphabets.hpp"
#include "common/kmer.hpp"
#include "common/base_types.hpp"
#include "common/sequence.hpp"
#include "utils/kmer_utils.hpp"
#include "utils/filter_utils.hpp"

#include "index/kmer_hash.hpp"
#include "common/kmer_transform.hpp"

#include "io/sequence_iterator.hpp"
#include "io/sequence_id_iterator.hpp"
#include "iterators/transform_iterator.hpp"
#include "common/kmer_iterators.hpp"
#include "iterators/zip_iterator.hpp"
#include "iterators/unzip_iterator.hpp"
#include "iterators/constant_iterator.hpp"
#include "index/quality_score_iterator.hpp"
#include "containers/fsc_container_utils.hpp"

namespace bliss
{
namespace index
{
namespace kmer
{


template <typename Iter>
using NonEOLIter = bliss::iterator::filter_iterator<::bliss::utils::file::NotEOL, Iter>;


/**
 * @tparam KmerType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename KmerType>
class KmerParser {

public:
    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = KmerType;
  using kmer_type = KmerType;
  static constexpr size_t window_size = kmer_type::size;

protected:
  using Alphabet = typename kmer_type::KmerAlphabet;

  // filter out EOL characters
  template <typename SeqType>
  using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;

  // converter from ascii to alphabet values
  template <typename SeqType>
  using BaseCharIterator = bliss::iterator::transform_iterator<CharIter<SeqType>, bliss::common::ASCII2<Alphabet> >;




  ::bliss::partition::range<size_t> valid_range;

public:
  /// adjust the ends.
  template <typename SeqType>
  static std::tuple<typename SeqType::IteratorType, typename SeqType::IteratorType, bool>
  get_valid_iterator_range(SeqType const & read, ::bliss::partition::range<size_t> const & valid_r, size_t window) {
      // search for end.  should be either read.seq_end or valid_range.end + windows - 1.
      ::bliss::partition::range<size_t> seq_range(read.seq_global_offset(),
    		  read.seq_global_offset() + read.seq_size());

	  // not symmetric - want to keep seq_range values preferentially.
	  ::bliss::partition::range<size_t> valid_seq_range = ::bliss::partition::range<size_t>::intersect(seq_range, valid_r);

	  //std::cout << "valid seq range: " << valid_seq_range << std::endl;

	  typename SeqType::IteratorType seq_begin = read.seq_begin;
	  std::advance(seq_begin, (valid_seq_range.start - seq_range.start));  // the new positions.
	  typename SeqType::IteratorType seq_end = seq_begin;
	  std::advance(seq_end, valid_seq_range.size());

      // if have intersection with valid_range and if there is overlap, i.e. seq_range.end > valid_range.end,
	  if ((seq_range.end > valid_r.end) && (valid_seq_range.size() > 0)) {
		// then scan from seq_end forward

		  CharIter<SeqType> iter(bliss::utils::file::NotEOL(), seq_end, read.seq_end);  // iterate from end of valid range to end of read
		  // iterate window_size - 1 steps;  since this is essentially a filter iterator, it won't go past end.
		  std::advance(iter, window - 1);

		  // get what the filter iterator is pointing to.
		  seq_end = iter.getBaseIterator();
	  }
      // now the ends are at where we need them to be.

	  // ==== now check to see if we have at least window number of entries.
	  CharIter<SeqType> iter(bliss::utils::file::NotEOL(), seq_begin, seq_end);  // iterate from end of valid range to end of read
	  CharIter<SeqType> max(bliss::utils::file::NotEOL(), seq_end);  // iterate from end of valid range to end of read
	  size_t i = 0;
	  for (; (iter != max) && (i < window); ++iter) { ++i;};
	  // get what the filter iterator is pointing to.

//	  std::cout << " dist from front " << std::distance(read.seq_begin, seq_begin) << " to end " << std::distance(seq_end, read.seq_end) << std::endl;
//	  std::cout << " read dist  " << std::distance(read.seq_begin, read.seq_end) << " valid " << std::distance(seq_begin, seq_end) << std::endl;
//	  std::cout << " has window size? " << i << " of window " << window << std::endl;
//	  std::cout << " seq valid range: [" << (read.seq_global_offset() + std::distance(read.seq_begin, seq_begin)) << "-" << (read.seq_global_offset() + std::distance(read.seq_begin, seq_end)) << ")" <<
//			  " assigned range: [" << read.seq_global_offset() << "-" << (read.seq_global_offset() + std::distance(read.seq_begin, read.seq_end)) << ")" <<
//			  " full range: [" << read.id.get_pos() << "-" << (read.id.get_pos() + read.record_size) << ")" <<
//			  std::endl;
	  return std::make_tuple(seq_begin, seq_end, i >= window);
  }



  // kmer generation iterator
  template <typename SeqType>
  using iterator_type = bliss::common::KmerGenerationIterator<BaseCharIterator<SeqType>, kmer_type>;


  KmerParser(::bliss::partition::range<size_t> const & _valid_range) : valid_range(_valid_range) {};


  template <typename SeqType>
  iterator_type<SeqType> begin(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window = false;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      if (has_window) {
		  return iterator_type<SeqType>(BaseCharIterator<SeqType>(
				  CharIter<SeqType>(neol, seq_begin, seq_end),
				  bliss::common::ASCII2<Alphabet>()),
				  true);
      } else {
          return iterator_type<SeqType>(BaseCharIterator<SeqType>(
        		  CharIter<SeqType>(neol, seq_end),
        		  bliss::common::ASCII2<Alphabet>()),
        		  false);
      }
  }

  template <typename SeqType>
  iterator_type<SeqType> end(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window = false;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);


      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      return iterator_type<SeqType>(BaseCharIterator<SeqType>(
    		  CharIter<SeqType>(neol, seq_end),
    		  bliss::common::ASCII2<Alphabet>()),
    		  false);

  }



  /**
   * @brief generate kmers from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::bliss::filter::TruePredicate>
  OutputIt operator()(SeqType const & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<KmerType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
            "output type and output container value type are not the same");

//    using Alphabet = typename KmerType::KmerAlphabet;
//
//    /// converter from ascii to alphabet values
//    using BaseCharIterator = bliss::iterator::transform_iterator<NonEOLIter<typename SeqType::IteratorType>, bliss::common::ASCII2<Alphabet> >;
//
//    /// kmer generation iterator
//    using KmerIterType = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerIterType>::value_type,
//        KmerType>::value,
//        "input iterator and output iterator's value types differ");
//
//    // then compute and store into index (this will generate kmers and insert into index)
//    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;
//
//    //== filtering iterator
//    bliss::utils::file::NotEOL neol;
//    NonEOLIter<typename SeqType::IteratorType> eolstart(neol, read.seq_begin, read.seq_end);
//    NonEOLIter<typename SeqType::IteratorType> eolend(neol, read.seq_end);
//
//    //== set up the kmer generating iterators.
//    KmerIterType start(BaseCharIterator(eolstart, bliss::common::ASCII2<Alphabet>()), true);
//    KmerIterType end(BaseCharIterator(eolend, bliss::common::ASCII2<Alphabet>()), false);
//
//
//
////    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());
//
//    ::bliss::partition::range<size_t> seq_range(read.seq_global_offset(), read.seq_global_offset() + read.seq_size());
//    if (seq_range.contains(valid_range.end)) {
//      // seq_range contains overlap.
//
//      // not checking by end iterator at valid_range.end, since the NonEOLIter is a filter iterator that may skip over that pos.
//      int64_t valid_dist = valid_range.end - seq_range.start;
//
//      for (auto it = start; it != end; ++it, ++output_iter) {
//        // check tail of window -> transform iterator, get base -> non EOL iterator, get base -> seq raw char iter.
//        if (std::distance(read.seq_begin, it.getTrailingIterator().getBaseIterator().getBaseIterator()) >= valid_dist) {
//          break;
//        }
//
//        *output_iter = *it;
//      }
//      return output_iter;
//
//    } else {
////      if (::std::is_same<typename std::remove_reference<typename std::remove_cv<Predicate>::type>::type, ::bliss::filter::TruePredicate>::value)
//        return ::std::copy(start, end, output_iter);
////      else
////        return ::std::copy_if(start, end, output_iter, pred);
//    }
    iterator_type<SeqType> istart = begin(read, window_size);
    iterator_type<SeqType> iend = end(read, window_size);

    return std::copy(istart, iend, output_iter);
  }
};

template <typename KmerType>
constexpr size_t KmerParser<KmerType>::window_size;


/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType>
class KmerPositionTupleParser {

public:

    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;
  using IdType = typename std::tuple_element<1, value_type>::type;
  static constexpr size_t window_size = kmer_type::size;


protected:
  using Alphabet = typename kmer_type::KmerAlphabet;

  // filter out EOL characters
  template <typename SeqType>
  using CharIter = ::bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;

  // converter from ascii to alphabet values
  template <typename SeqType>
  using BaseCharIterator = bliss::iterator::transform_iterator<CharIter<SeqType>, bliss::common::ASCII2<Alphabet> >;

  // kmer generation iterator
  template <typename SeqType>
  using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator<SeqType>, kmer_type>;

  //== next figure out starting positions for the kmers, accounting for EOL char presenses.
  // kmer position iterator type
  using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;

  // use zip iterator to tie together the iteration of sequence raw data and id.
  template <typename SeqType>
  using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;
  // iterating over nonEOL characters also increments Id.
  template <typename SeqType>
  using CharPosIter = ::bliss::index::kmer::NonEOLIter<PairedIter<SeqType> >;
  // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
  // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
  template <typename SeqType>
  using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter<SeqType>, 1>;



  ::bliss::partition::range<size_t> valid_range;


public:
  // rezip the results
  template <typename SeqType>
  using iterator_type = bliss::iterator::ZipIterator<KmerIter<SeqType>, IdIter<SeqType> >;


  KmerPositionTupleParser(::bliss::partition::range<size_t> const & _valid_range) : valid_range(_valid_range) {};


  template <typename SeqType>
  iterator_type<SeqType> begin(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");
      static_assert(::std::tuple_size<value_type>::value == 2,
    		  "kmer-pos index data type should be a pair");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window = false;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      //== set up the position iterators
      IdType seq_begin_id(read.id);
      seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
      seq_begin_id += std::distance(read.seq_begin, seq_begin);
      IdType seq_end_id(seq_begin_id);
      seq_end_id += std::distance(seq_begin, seq_end);

      // tie chars and id together
      PairedIter<SeqType> pp_begin(seq_begin, IdIterType(seq_begin_id));
      PairedIter<SeqType> pp_end(seq_end, IdIterType(seq_end_id));

      // filter eol

      // ==== extract new id and rezip iterators
      if (has_window) {
          KmerIter<SeqType> start(BaseCharIterator<SeqType>(
        		  CharIter<SeqType>(neol, seq_begin, seq_end),
        		  bliss::common::ASCII2<Alphabet>()),
        		  true);

//          CharPosIter<SeqType> cp_begin(neol, pp_begin, pp_end);

          return iterator_type<SeqType>(start, IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_begin, pp_end)) );
      // ==== extract new id and rezip iterators
      } else {
          KmerIter<SeqType> end(BaseCharIterator<SeqType>(
        		  CharIter<SeqType>(neol, seq_end),
        		  bliss::common::ASCII2<Alphabet>()),
        		  false);
//          CharPosIter<SeqType> cp_end(neol, pp_end);

          return iterator_type<SeqType>(end, IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_end)) );

      }

  }

  template <typename SeqType>
  iterator_type<SeqType> end(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");
      static_assert(::std::tuple_size<value_type>::value == 2,
    		  "kmer-pos index data type should be a pair");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window = false;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);


      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      KmerIter<SeqType> end(BaseCharIterator<SeqType>(
    		  CharIter<SeqType>(neol, seq_end),
    		  bliss::common::ASCII2<Alphabet>()),
    		  false);

      //== set up the position iterators
      IdType seq_end_id(read.id);
      seq_end_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
      seq_end_id += std::distance(read.seq_begin, seq_end);

      // tie chars and id together
      PairedIter<SeqType> pp_end(seq_end, IdIterType(seq_end_id));

      // filter eol
      //CharPosIter<SeqType> cp_end(neol, pp_end);

      // ==== extract new id and rezip iterators
      return iterator_type<SeqType>(end, IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_end)));
  }




  /**
   * @brief generate kmer-position pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::bliss::filter::TruePredicate>
  OutputIt operator()(SeqType const & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
            "output type and output container value type are not the same");

//    static_assert(::std::tuple_size<TupleType>::value == 2,
//  		  "kmer-pos index data type should be a pair");
//
//    using KmerType = typename std::tuple_element<0, TupleType>::type;
//    using Alphabet = typename KmerType::KmerAlphabet;
//
//    // filter out EOL characters
//    using CharIter = NonEOLIter<typename SeqType::IteratorType>;
//    // converter from ascii to alphabet values
//    using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
//    // kmer generation iterator
//    using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;
//
//    //== next figure out starting positions for the kmers, accounting for EOL char presenses.
//    using IdType = typename std::tuple_element<1, TupleType>::type;
//    // kmer position iterator type
//    using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;
//
//    // use zip iterator to tie together the iteration of sequence raw data and id.
//    using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;
//    using CharPosIter = NonEOLIter<PairedIter>;
//    // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
//    // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
//    using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter, 1>;
//
//    // rezip the results
//    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, IdIter>;
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
//        TupleType>::value,
//        "input iterator and output iterator's value types differ");
//
//
//    // then compute and store into index (this will generate kmers and insert into index)
//    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;  // if too short...
//
//    //== set up the kmer generating iterators.
//    bliss::utils::file::NotEOL neol;
//    KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
//    KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);
//
//
//    //== set up the position iterators
//    IdType seq_begin_id(read.id);
//    seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
//    IdType seq_end_id(seq_begin_id);
//    seq_end_id += read.seq_size();
//
//    // tie chars and id together
//    PairedIter pp_begin(read.seq_begin, IdIterType(seq_begin_id));
//    PairedIter pp_end(read.seq_end, IdIterType(seq_end_id));
//
//    // filter eol
//    CharPosIter cp_begin(neol, pp_begin, pp_end);
//    CharPosIter cp_end(neol, pp_end);
//
//    // ==== extract new id and rezip iterators
//    KmerIndexIterType index_start(start, IdIter(cp_begin));
//    KmerIndexIterType index_end(end, IdIter(cp_end));
//
//
////    for (; index_start != index_end; ++index_start) {
////      auto tp = *index_start;
////
////      printf("TCP id = %lu, pos = %lu, kmer = %s\n", tp.second.get_id(), tp.second.get_pos(), bliss::utils::KmerUtils::toASCIIString(tp.first).c_str());
////
////      *output_iter = tp;
////
////    }
//
//    ::bliss::partition::range<size_t> seq_range(read.seq_global_offset(), read.seq_global_offset() + read.seq_size());
//    if (seq_range.contains(valid_range.end)) {
//      // seq_range contains overlap.
//
//      // not checking by end iterator at valid_range.end, since the NonEOLIter is a filter iterator that may skip over that pos.
//
//      for (auto it = index_start; it != index_end; ++it, ++output_iter) {
//        // check tail of window -> transform iterator, get base -> non EOL iterator, get base -> seq raw char iter.
//        if ((*it).second.get_pos() >= valid_range.end) {
//          break;
//        }
//
//        *output_iter = *it;
//      }
//
//      return output_iter;
//
//    } else {
//
//        return ::std::copy(index_start, index_end, output_iter);
//    }

    iterator_type<SeqType> istart = begin(read, window_size);
    iterator_type<SeqType> iend = end(read, window_size);

    return std::copy(istart, iend, output_iter);

  }

};

template <typename TupleType>
constexpr size_t KmerPositionTupleParser<TupleType>::window_size;

/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType, template<typename> class QualityEncoder = bliss::index::Illumina18QualityScoreCodec>
class KmerPositionQualityTupleParser {

public:
    /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;
  using mapped_type = typename ::std::tuple_element<1, value_type>::type;
  using IdType = typename std::tuple_element<0, mapped_type >::type;
  using QualType = typename std::tuple_element<1, mapped_type>::type;
  static constexpr size_t window_size = kmer_type::size;

protected:
  using Alphabet = typename kmer_type::KmerAlphabet;

  static_assert(::std::tuple_size<mapped_type>::value == 2, "pos-qual index data type should be a pair");

  // filter out EOL characters
  template <typename SeqType>
  using CharIter = NonEOLIter<typename SeqType::IteratorType>;

  // converter from ascii to alphabet values
  template <typename SeqType>
  using BaseCharIterator = bliss::iterator::transform_iterator<CharIter<SeqType>, bliss::common::ASCII2<Alphabet> >;

  // kmer generation iterator
  template <typename SeqType>
  using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator<SeqType>, kmer_type>;

  //== next figure out starting positions for the kmers, accounting for EOL char presenses.
  // kmer position iterator type
  using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;

  // use zip iterator to tie together the iteration of sequence raw data and id.
  template <typename SeqType>
  using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;

  template <typename SeqType>
  using CharPosIter = ::bliss::index::kmer::NonEOLIter<PairedIter<SeqType> >;
  // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
  // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
  template <typename SeqType>
  using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter<SeqType>, 1>;


  // also remove eol from quality score
  template <typename SeqType>
  using QualIterType =
      bliss::index::QualityScoreGenerationIterator<NonEOLIter<typename SeqType::IteratorType>, kmer_type::size, QualityEncoder<QualType> >;

  /// combine kmer iterator and position iterator to create an index iterator type.
  template <typename SeqType>
  using KmerInfoIterType = bliss::iterator::ZipIterator<IdIter<SeqType>, QualIterType<SeqType> >;


  ::bliss::partition::range<size_t> valid_range;

public:
  template <typename SeqType>
  using iterator_type = bliss::iterator::ZipIterator<KmerIter<SeqType>, KmerInfoIterType<SeqType> >;


  KmerPositionQualityTupleParser(::bliss::partition::range<size_t> const & _valid_range) : valid_range(_valid_range) {};

  template <typename SeqType>
  iterator_type<SeqType> begin(SeqType const & read, size_t const & window = window_size) const {
	    static_assert(SeqType::has_quality(), "Sequence Parser needs to support quality scores");
	    static_assert(::std::tuple_size<value_type>::value == 2, "kmer-pos-qual index data type should be a pair");
	    static_assert(::std::tuple_size<typename std::tuple_element<1, value_type>::type>::value == 2, "pos-qual index data type should be a pair");

	  static_assert(std::is_same<typename std::iterator_traits<KmerInfoIterType<SeqType> >::value_type,
	      mapped_type >::value,
	      "kmer info input iterator and output iterator's value types differ");

      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");

      assert(::std::distance(read.seq_begin, read.seq_end) <= ::std::distance(read.qual_begin, read.qual_end));

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      typename SeqType::IteratorType qual_begin = read.qual_begin;
      std::advance(qual_begin, std::distance(read.seq_begin, seq_begin));
      typename SeqType::IteratorType qual_end = qual_begin;
      std::advance(qual_end, std::distance(seq_begin, seq_end));


      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      //== set up the position iterators
      IdType seq_begin_id(read.id);
      seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
      seq_begin_id += std::distance(read.seq_begin, seq_begin);
      IdType seq_end_id(seq_begin_id);
      seq_end_id += std::distance(seq_begin, seq_end);

      // tie chars and id together
      PairedIter<SeqType> pp_begin(seq_begin, IdIterType(seq_begin_id));
      PairedIter<SeqType> pp_end(seq_end, IdIterType(seq_end_id));


      // ==== set up the zip iterators
      if (has_window) {
          KmerIter<SeqType> start(BaseCharIterator<SeqType>(
        		  CharIter<SeqType>(neol, seq_begin, seq_end),
    			  bliss::common::ASCII2<Alphabet>()), true);
          //CharPosIter<SeqType> cp_begin(neol, pp_begin, pp_end);
          QualIterType<SeqType> qual_start(CharIter<SeqType>(neol, qual_begin, qual_end));
          KmerInfoIterType<SeqType> info_start(IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_begin, pp_end) ), qual_start);
    	  return iterator_type<SeqType>(start, info_start);
      } else {
          KmerIter<SeqType> end(BaseCharIterator<SeqType>(
        		  CharIter<SeqType>(neol, seq_end),
    			  bliss::common::ASCII2<Alphabet>()), false);
//          CharPosIter<SeqType> cp_end(neol, pp_end);
          QualIterType<SeqType> qual_end_iter(CharIter<SeqType>(neol, qual_end));
          KmerInfoIterType<SeqType> info_end(IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_end)), qual_end_iter);
          return iterator_type<SeqType>(end, info_end);
      }
  }

  template <typename SeqType>
  iterator_type<SeqType> end(SeqType const & read, size_t const & window = window_size) const {

    static_assert(SeqType::has_quality(), "Sequence Parser needs to support quality scores");
    static_assert(::std::tuple_size<value_type>::value == 2, "kmer-pos-qual index data type should be a pair");
    static_assert(::std::tuple_size<typename std::tuple_element<1, value_type>::type>::value == 2, "pos-qual index data type should be a pair");


	  static_assert(std::is_same<typename std::iterator_traits<KmerInfoIterType<SeqType> >::value_type,
	      mapped_type >::value,
	      "kmer info input iterator and output iterator's value types differ");

      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");

      assert(::std::distance(read.seq_begin, read.seq_end) <= ::std::distance(read.qual_begin, read.qual_end));

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      typename SeqType::IteratorType qual_end = read.qual_begin;
      std::advance(qual_end, std::distance(read.seq_begin, seq_end));


      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;
      KmerIter<SeqType> end(BaseCharIterator<SeqType>(CharIter<SeqType>(neol, seq_end), bliss::common::ASCII2<Alphabet>()), false);


      //== set up the position iterators
      IdType seq_end_id(read.id);
      seq_end_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
      seq_end_id += std::distance(read.seq_begin, seq_end);

      // tie chars and id together
      PairedIter<SeqType> pp_end(seq_end, IdIterType(seq_end_id));

      // filter eol
//      CharPosIter<SeqType> cp_end(neol, pp_end);

      // ==== quality scoring
      // filter eol and generate quality scores
      QualIterType<SeqType> qual_end_iter(CharIter<SeqType>(neol, qual_end));

      KmerInfoIterType<SeqType> info_end(IdIter<SeqType>(std::make_shared<CharPosIter<SeqType> >(neol, pp_end)), qual_end_iter);


      // ==== set up the zip iterators
      return iterator_type<SeqType>(end, info_end);

  }


  /**
   * @brief generate kmer-position-quality pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::bliss::filter::TruePredicate>
  OutputIt operator()(SeqType const & read, OutputIt output_iter, Predicate const & pred = Predicate()) {


//    static_assert(SeqType::has_quality(), "Sequence Parser needs to support quality scores");

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
        "output type and output container value type are not the same");

//    static_assert(::std::tuple_size<TupleType>::value == 2, "kmer-pos-qual index data type should be a pair");
//
//    using KmerType = typename std::tuple_element<0, TupleType>::type;
//    using Alphabet = typename KmerType::KmerAlphabet;
//
//    static_assert(::std::tuple_size<typename std::tuple_element<1, TupleType>::type>::value == 2, "pos-qual index data type should be a pair");
//
//
//    // filter out EOL characters
//    using CharIter = NonEOLIter<typename SeqType::IteratorType>;
//    // converter from ascii to alphabet values
//    using BaseCharIterator = bliss::iterator::transform_iterator<CharIter, bliss::common::ASCII2<Alphabet> >;
//    // kmer generation iterator
//    using KmerIter = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;
//
//    //== next figure out starting positions for the kmers, accounting for EOL char presenses.
//    using IdType = typename std::tuple_element<0, typename std::tuple_element<1, TupleType>::type >::type;
//    // kmer position iterator type
//    using IdIterType = bliss::iterator::SequenceIdIterator<IdType>;
//
//    // use zip iterator to tie together the iteration of sequence raw data and id.
//    using PairedIter = bliss::iterator::ZipIterator<typename SeqType::IteratorType, IdIterType>;
//    using CharPosIter = NonEOLIter<PairedIter>;
//    // now use 2 unzip iterators to access the values.  one of them advances.  all subsequent wrapping
//    // iterators trickle back to the zip iterator above, again, one of the 2 unzip iterator will call operator++ on the underlying zip iterator
//    using IdIter = bliss::iterator::AdvancingUnzipIterator<CharPosIter, 1>;
//
//
//    using QualType = typename std::tuple_element<1, typename std::tuple_element<1, TupleType>::type>::type;
//    //static_assert(::std::is_same<typename SeqType::IdType, IdType>::value, "position type does not match for input and output iterators" );
//
//    // also remove eol from quality score
//    using QualIterType =
//        bliss::index::QualityScoreGenerationIterator<NonEOLIter<typename SeqType::IteratorType>, KmerType::size, QualityEncoder<QualType> >;
//
//    /// combine kmer iterator and position iterator to create an index iterator type.
//    using KmerInfoIterType = bliss::iterator::ZipIterator<IdIter, QualIterType>;
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerInfoIterType>::value_type,
//        typename std::tuple_element<1, TupleType>::type >::value,
//        "kmer info input iterator and output iterator's value types differ");
//
//
//    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIter, KmerInfoIterType>;
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
//        TupleType>::value,
//        "input iterator and output iterator's value types differ");
//
//
//    // then compute and store into index (this will generate kmers and insert into index)
//    if ((::std::distance(read.seq_begin, read.seq_end) < KmerType::size) ||
//        (::std::distance(read.qual_begin, read.qual_end) < KmerType::size)) return output_iter;
//    assert(::std::distance(read.seq_begin, read.seq_end) <= ::std::distance(read.qual_begin, read.qual_end));
//
//
//    //== set up the kmer generating iterators.
//    bliss::utils::file::NotEOL neol;
//    KmerIter start(BaseCharIterator(CharIter(neol, read.seq_begin, read.seq_end), bliss::common::ASCII2<Alphabet>()), true);
//    KmerIter end(BaseCharIterator(CharIter(neol, read.seq_end), bliss::common::ASCII2<Alphabet>()), false);
//
//
//    //== set up the position iterators
//    IdType seq_begin_id(read.id);
//    seq_begin_id += read.seq_begin_offset;  // change id to point to start of sequence (in file coord)
//    IdType seq_end_id(seq_begin_id);
//    seq_end_id += read.seq_size();
//
//    // tie chars and id together
//    PairedIter pp_begin(read.seq_begin, IdIterType(seq_begin_id));
//    PairedIter pp_end(read.seq_end, IdIterType(seq_end_id));
//
//    // filter eol
//    CharPosIter cp_begin(neol, pp_begin, pp_end);
//    CharPosIter cp_end(neol, pp_end);
//
//    // ==== quality scoring
//    // filter eol and generate quality scores
//    QualIterType qual_start(CharIter(neol, read.qual_begin, read.qual_end));
//    QualIterType qual_end(CharIter(neol, read.qual_end));
//
//    KmerInfoIterType info_start(IdIter(cp_begin), qual_start);
//    KmerInfoIterType info_end(IdIter(cp_end), qual_end);
//
//
//    // ==== set up the zip iterators
//    KmerIndexIterType index_start(start, info_start);
//    KmerIndexIterType index_end(end, info_end);
//
//    //    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());
//
//    ::bliss::partition::range<size_t> seq_range(read.seq_global_offset(), read.seq_global_offset() + read.seq_size());
//    if (seq_range.contains(valid_range.end)) {
//      // seq_range contains overlap.
//
//      // not checking by end iterator at valid_range.end, since the NonEOLIter is a filter iterator that may skip over that pos.
//
//      for (auto it = index_start; it != index_end; ++it, ++output_iter) {
//        // check tail of window -> transform iterator, get base -> non EOL iterator, get base -> seq raw char iter.
//        if ((*it).second.first.get_pos() >= valid_range.end) {
//          break;
//        }
//
//        *output_iter = *it;
//      }
//
//      return output_iter;
//
//    } else {
//
//
//        return ::std::copy(index_start, index_end, output_iter);
//    }

    iterator_type<SeqType> istart = begin(read, window_size);
    iterator_type<SeqType> iend = end(read, window_size);

    return std::copy(istart, iend, output_iter);

  }
};

template <typename TupleType, template<typename> class QualityEncoder>
constexpr size_t KmerPositionQualityTupleParser<TupleType, QualityEncoder>::window_size;


/**
 * @tparam TupleType       output value type of this parser.  not necessarily the same as the map's final storage type.
 */
template <typename TupleType>
class KmerCountTupleParser {

public:
  /// type of element generated by this parser.  since kmer itself is parameterized, this is not hard coded.
  using value_type = TupleType;
  using kmer_type = typename ::std::tuple_element<0, value_type>::type;
  using mapped_type = typename ::std::tuple_element<1, value_type>::type;
  static constexpr size_t window_size = kmer_type::size;

protected:
  using Alphabet = typename kmer_type::KmerAlphabet;

  // filter out EOL characters
  template <typename SeqType>
  using CharIter = bliss::index::kmer::NonEOLIter<typename SeqType::IteratorType>;

  // converter from ascii to alphabet values
  template <typename SeqType>
  using BaseCharIterator = bliss::iterator::transform_iterator<CharIter<SeqType>, bliss::common::ASCII2<Alphabet> >;

  // kmer generation iterator
  template <typename SeqType>
  using KmerIterType = bliss::common::KmerGenerationIterator<BaseCharIterator<SeqType>, kmer_type>;

  /// kmer generation iterator
  using CountIterType = bliss::iterator::ConstantIterator<mapped_type>;

  ::bliss::partition::range<size_t> valid_range;

public:
  template <typename SeqType>
  using iterator_type = bliss::iterator::ZipIterator<KmerIterType<SeqType>, CountIterType>;


  KmerCountTupleParser(::bliss::partition::range<size_t> const & _valid_range) : valid_range(_valid_range) {};

  template <typename SeqType>
  iterator_type<SeqType> begin(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");
      static_assert(::std::tuple_size<value_type>::value == 2, "count data type should be a pair");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      if (has_window) {
          CharIter<SeqType> eolstart(neol, seq_begin, seq_end);
          KmerIterType<SeqType> start(BaseCharIterator<SeqType>(eolstart, bliss::common::ASCII2<Alphabet>()), true);
    	  return iterator_type<SeqType>(start, CountIterType(1));
      } else {
          CharIter<SeqType> eolend(neol, seq_end);
          KmerIterType<SeqType> end(BaseCharIterator<SeqType>(eolend, bliss::common::ASCII2<Alphabet>()), false);
          return iterator_type<SeqType>(end, CountIterType(1));
      }
  }

  template <typename SeqType>
  iterator_type<SeqType> end(SeqType const & read, size_t const & window = window_size) const {
      static_assert(std::is_same<typename std::iterator_traits<iterator_type<SeqType> >::value_type,
                    value_type>::value,
                    "Generating iterator value type differs from expected");
      static_assert(::std::tuple_size<value_type>::value == 2, "count data type should be a pair");

      typename SeqType::IteratorType seq_begin;
      typename SeqType::IteratorType seq_end;
      bool has_window;

      std::tie(seq_begin, seq_end, has_window) =
    		  ::bliss::index::kmer::KmerParser<kmer_type>::get_valid_iterator_range(read, valid_range, window);

      //== set up the kmer generating iterators.
      bliss::utils::file::NotEOL neol;

      CharIter<SeqType> eolend(neol, seq_end);

      KmerIterType<SeqType> end(BaseCharIterator<SeqType>(eolend, bliss::common::ASCII2<Alphabet>()), false);

      return iterator_type<SeqType>(end, CountIterType(1));
  }



  /**
   * @brief generate kmer-count pairs from 1 sequence.  result inserted into output_iter, which may be preallocated.
   * @param read          sequence object, which has pointers to the raw byte array.
   * @param output_iter   output iterator pointing to insertion point for underlying container.
   * @return new position for output_iter
   * @tparam SeqType      type of sequence.  inferred.
   * @tparam OutputIt     output iterator type, inferred.
   */
  template <typename SeqType, typename OutputIt, typename Predicate = ::bliss::filter::TruePredicate>
  OutputIt operator()(SeqType const & read, OutputIt output_iter, Predicate const & pred = Predicate()) {

    static_assert(std::is_same<TupleType, typename ::std::iterator_traits<OutputIt>::value_type>::value,
        "output type and output container value type are not the same");
//    static_assert(::std::tuple_size<TupleType>::value == 2, "count data type should be a pair");
//
//    using KmerType = typename std::tuple_element<0, TupleType>::type;
//    using CountType = typename std::tuple_element<1, TupleType>::type;
//
//    using Alphabet = typename KmerType::KmerAlphabet;
//
//    /// converter from ascii to alphabet values
//    using BaseCharIterator = bliss::iterator::transform_iterator<NonEOLIter<typename SeqType::IteratorType>, bliss::common::ASCII2<Alphabet> >;
//
//    /// kmer generation iterator
//    using KmerIterType = bliss::common::KmerGenerationIterator<BaseCharIterator, KmerType>;
//    using CountIterType = bliss::iterator::ConstantIterator<CountType>;
//
//    using KmerIndexIterType = bliss::iterator::ZipIterator<KmerIterType, CountIterType>;
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type, std::pair<KmerType, CountType> >::value,
//        "count zip iterator not producing the right type.");
//
//    static_assert(std::is_same<typename std::iterator_traits<KmerIndexIterType>::value_type,
//        TupleType>::value,
//        "count: input iterator and output iterator's value types differ");
//
//    CountIterType count_start(1);
//
//    // then compute and store into index (this will generate kmers and insert into index)
//    if (::std::distance(read.seq_begin, read.seq_end) < KmerType::size) return output_iter;
//
//    //== set up the kmer generating iterators.
//    bliss::utils::file::NotEOL neol;
//    NonEOLIter<typename SeqType::IteratorType> eolstart(neol, read.seq_begin, read.seq_end);
//    NonEOLIter<typename SeqType::IteratorType> eolend(neol, read.seq_end);
//
//    KmerIterType start(BaseCharIterator(eolstart, bliss::common::ASCII2<Alphabet>()), true);
//    KmerIterType end(BaseCharIterator(eolend, bliss::common::ASCII2<Alphabet>()), false);
//
//    KmerIndexIterType istart(start, count_start);
//    KmerIndexIterType iend(end, count_start);
//
//    //    printf("First: pos %lu kmer %s\n", read.id.id, bliss::utils::KmerUtils::toASCIIString(*start).c_str());
//
//    ::bliss::partition::range<size_t> seq_range(read.seq_global_offset(), read.seq_global_offset() + read.seq_size());
//    if (seq_range.contains(valid_range.end)) {
//      // seq_range contains overlap.
//
//      // not checking by end iterator at valid_range.end, since the NonEOLIter is a filter iterator that may skip over that pos.
//      int64_t valid_dist = valid_range.end - seq_range.start;
//
//      for (auto it = istart; it != iend; ++it, ++output_iter) {
//        // check tail of window -> transform iterator, get base -> non EOL iterator, get base -> seq raw char iter.
//        if (std::distance(read.seq_begin,
//                          it.get_first_iterator().getTrailingIterator().getBaseIterator().getBaseIterator()) >= valid_dist) {
//          break;
//        }
//
//        *output_iter = *it;
//      }
//
//      return output_iter;
//
//    } else {
//        return ::std::copy(istart, iend, output_iter);
//    }

    iterator_type<SeqType> istart = begin(read, window_size);
    iterator_type<SeqType> iend = end(read, window_size);

    return std::copy(istart, iend, output_iter);
  }

};
template <typename TupleType>
constexpr size_t KmerCountTupleParser<TupleType>::window_size;


} /* namespace kmer */

} /* namespace index */
} /* namespace bliss */

#endif /* KMER_PARSER_HPP_ */
